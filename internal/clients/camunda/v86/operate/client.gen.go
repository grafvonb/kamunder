// Package operate provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package operate

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	Bearer_keyScopes = "bearer_key.Scopes"
	CookieScopes     = "cookie.Scopes"
)

// Defines values for DecisionInstanceDecisionType.
const (
	DecisionInstanceDecisionTypeDECISIONTABLE     DecisionInstanceDecisionType = "DECISION_TABLE"
	DecisionInstanceDecisionTypeLITERALEXPRESSION DecisionInstanceDecisionType = "LITERAL_EXPRESSION"
	DecisionInstanceDecisionTypeUNKNOWN           DecisionInstanceDecisionType = "UNKNOWN"
	DecisionInstanceDecisionTypeUNSPECIFIED       DecisionInstanceDecisionType = "UNSPECIFIED"
)

// Defines values for DecisionInstanceState.
const (
	DecisionInstanceStateEVALUATED   DecisionInstanceState = "EVALUATED"
	DecisionInstanceStateFAILED      DecisionInstanceState = "FAILED"
	DecisionInstanceStateUNKNOWN     DecisionInstanceState = "UNKNOWN"
	DecisionInstanceStateUNSPECIFIED DecisionInstanceState = "UNSPECIFIED"
)

// Defines values for FlowNodeInstanceState.
const (
	FlowNodeInstanceStateACTIVE     FlowNodeInstanceState = "ACTIVE"
	FlowNodeInstanceStateCOMPLETED  FlowNodeInstanceState = "COMPLETED"
	FlowNodeInstanceStateTERMINATED FlowNodeInstanceState = "TERMINATED"
)

// Defines values for FlowNodeInstanceType.
const (
	FlowNodeInstanceTypeBOUNDARYEVENT          FlowNodeInstanceType = "BOUNDARY_EVENT"
	FlowNodeInstanceTypeBUSINESSRULETASK       FlowNodeInstanceType = "BUSINESS_RULE_TASK"
	FlowNodeInstanceTypeCALLACTIVITY           FlowNodeInstanceType = "CALL_ACTIVITY"
	FlowNodeInstanceTypeENDEVENT               FlowNodeInstanceType = "END_EVENT"
	FlowNodeInstanceTypeEVENTBASEDGATEWAY      FlowNodeInstanceType = "EVENT_BASED_GATEWAY"
	FlowNodeInstanceTypeEVENTSUBPROCESS        FlowNodeInstanceType = "EVENT_SUB_PROCESS"
	FlowNodeInstanceTypeEXCLUSIVEGATEWAY       FlowNodeInstanceType = "EXCLUSIVE_GATEWAY"
	FlowNodeInstanceTypeINCLUSIVEGATEWAY       FlowNodeInstanceType = "INCLUSIVE_GATEWAY"
	FlowNodeInstanceTypeINTERMEDIATECATCHEVENT FlowNodeInstanceType = "INTERMEDIATE_CATCH_EVENT"
	FlowNodeInstanceTypeINTERMEDIATETHROWEVENT FlowNodeInstanceType = "INTERMEDIATE_THROW_EVENT"
	FlowNodeInstanceTypeMANUALTASK             FlowNodeInstanceType = "MANUAL_TASK"
	FlowNodeInstanceTypeMULTIINSTANCEBODY      FlowNodeInstanceType = "MULTI_INSTANCE_BODY"
	FlowNodeInstanceTypePARALLELGATEWAY        FlowNodeInstanceType = "PARALLEL_GATEWAY"
	FlowNodeInstanceTypePROCESS                FlowNodeInstanceType = "PROCESS"
	FlowNodeInstanceTypeRECEIVETASK            FlowNodeInstanceType = "RECEIVE_TASK"
	FlowNodeInstanceTypeSCRIPTTASK             FlowNodeInstanceType = "SCRIPT_TASK"
	FlowNodeInstanceTypeSENDTASK               FlowNodeInstanceType = "SEND_TASK"
	FlowNodeInstanceTypeSEQUENCEFLOW           FlowNodeInstanceType = "SEQUENCE_FLOW"
	FlowNodeInstanceTypeSERVICETASK            FlowNodeInstanceType = "SERVICE_TASK"
	FlowNodeInstanceTypeSTARTEVENT             FlowNodeInstanceType = "START_EVENT"
	FlowNodeInstanceTypeSUBPROCESS             FlowNodeInstanceType = "SUB_PROCESS"
	FlowNodeInstanceTypeTASK                   FlowNodeInstanceType = "TASK"
	FlowNodeInstanceTypeUNKNOWN                FlowNodeInstanceType = "UNKNOWN"
	FlowNodeInstanceTypeUNSPECIFIED            FlowNodeInstanceType = "UNSPECIFIED"
	FlowNodeInstanceTypeUSERTASK               FlowNodeInstanceType = "USER_TASK"
)

// Defines values for IncidentState.
const (
	IncidentStateACTIVE   IncidentState = "ACTIVE"
	IncidentStateMIGRATED IncidentState = "MIGRATED"
	IncidentStatePENDING  IncidentState = "PENDING"
	IncidentStateRESOLVED IncidentState = "RESOLVED"
)

// Defines values for IncidentType.
const (
	IncidentTypeCALLEDDECISIONERROR        IncidentType = "CALLED_DECISION_ERROR"
	IncidentTypeCALLEDELEMENTERROR         IncidentType = "CALLED_ELEMENT_ERROR"
	IncidentTypeCONDITIONERROR             IncidentType = "CONDITION_ERROR"
	IncidentTypeDECISIONEVALUATIONERROR    IncidentType = "DECISION_EVALUATION_ERROR"
	IncidentTypeEXECUTIONLISTENERNORETRIES IncidentType = "EXECUTION_LISTENER_NO_RETRIES"
	IncidentTypeEXTRACTVALUEERROR          IncidentType = "EXTRACT_VALUE_ERROR"
	IncidentTypeFORMNOTFOUND               IncidentType = "FORM_NOT_FOUND"
	IncidentTypeIOMAPPINGERROR             IncidentType = "IO_MAPPING_ERROR"
	IncidentTypeJOBNORETRIES               IncidentType = "JOB_NO_RETRIES"
	IncidentTypeMESSAGESIZEEXCEEDED        IncidentType = "MESSAGE_SIZE_EXCEEDED"
	IncidentTypeUNHANDLEDERROREVENT        IncidentType = "UNHANDLED_ERROR_EVENT"
	IncidentTypeUNKNOWN                    IncidentType = "UNKNOWN"
	IncidentTypeUNSPECIFIED                IncidentType = "UNSPECIFIED"
)

// Defines values for ProcessInstanceState.
const (
	ACTIVE    ProcessInstanceState = "ACTIVE"
	CANCELED  ProcessInstanceState = "CANCELED"
	COMPLETED ProcessInstanceState = "COMPLETED"
)

// Defines values for SortOrder.
const (
	ASC  SortOrder = "ASC"
	DESC SortOrder = "DESC"
)

// ChangeStatus defines model for ChangeStatus.
type ChangeStatus struct {
	Deleted *int64  `json:"deleted,omitempty"`
	Message *string `json:"message,omitempty"`
}

// DecisionDefinition defines model for DecisionDefinition.
type DecisionDefinition struct {
	DecisionId                  *string `json:"decisionId,omitempty"`
	DecisionRequirementsId      *string `json:"decisionRequirementsId,omitempty"`
	DecisionRequirementsKey     *int64  `json:"decisionRequirementsKey,omitempty"`
	DecisionRequirementsName    *string `json:"decisionRequirementsName,omitempty"`
	DecisionRequirementsVersion *int32  `json:"decisionRequirementsVersion,omitempty"`
	Id                          *string `json:"id,omitempty"`
	Key                         *int64  `json:"key,omitempty"`
	Name                        *string `json:"name,omitempty"`
	TenantId                    *string `json:"tenantId,omitempty"`
	Version                     *int32  `json:"version,omitempty"`
}

// DecisionInstance defines model for DecisionInstance.
type DecisionInstance struct {
	DecisionDefinitionId *string                       `json:"decisionDefinitionId,omitempty"`
	DecisionId           *string                       `json:"decisionId,omitempty"`
	DecisionName         *string                       `json:"decisionName,omitempty"`
	DecisionType         *DecisionInstanceDecisionType `json:"decisionType,omitempty"`
	DecisionVersion      *int32                        `json:"decisionVersion,omitempty"`
	EvaluatedInputs      *[]DecisionInstanceInput      `json:"evaluatedInputs,omitempty"`
	EvaluatedOutputs     *[]DecisionInstanceOutput     `json:"evaluatedOutputs,omitempty"`
	EvaluationDate       *string                       `json:"evaluationDate,omitempty"`
	EvaluationFailure    *string                       `json:"evaluationFailure,omitempty"`
	Id                   *string                       `json:"id,omitempty"`
	Key                  *int64                        `json:"key,omitempty"`
	ProcessDefinitionKey *int64                        `json:"processDefinitionKey,omitempty"`
	ProcessInstanceKey   *int64                        `json:"processInstanceKey,omitempty"`
	Result               *string                       `json:"result,omitempty"`
	State                *DecisionInstanceState        `json:"state,omitempty"`
	TenantId             *string                       `json:"tenantId,omitempty"`
}

// DecisionInstanceDecisionType defines model for DecisionInstance.DecisionType.
type DecisionInstanceDecisionType string

// DecisionInstanceState defines model for DecisionInstance.State.
type DecisionInstanceState string

// DecisionInstanceInput defines model for DecisionInstanceInput.
type DecisionInstanceInput struct {
	Id    *string `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// DecisionInstanceOutput defines model for DecisionInstanceOutput.
type DecisionInstanceOutput struct {
	Id        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
	RuleId    *string `json:"ruleId,omitempty"`
	RuleIndex *int32  `json:"ruleIndex,omitempty"`
	Value     *string `json:"value,omitempty"`
}

// DecisionRequirements defines model for DecisionRequirements.
type DecisionRequirements struct {
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`
	Id                     *string `json:"id,omitempty"`
	Key                    *int64  `json:"key,omitempty"`
	Name                   *string `json:"name,omitempty"`
	ResourceName           *string `json:"resourceName,omitempty"`
	TenantId               *string `json:"tenantId,omitempty"`
	Version                *int32  `json:"version,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Instance *string `json:"instance,omitempty"`
	Message  *string `json:"message,omitempty"`
	Status   *int32  `json:"status,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// FlowNodeInstance defines model for FlowNodeInstance.
type FlowNodeInstance struct {
	EndDate              *string                `json:"endDate,omitempty"`
	FlowNodeId           *string                `json:"flowNodeId,omitempty"`
	FlowNodeName         *string                `json:"flowNodeName,omitempty"`
	Incident             *bool                  `json:"incident,omitempty"`
	IncidentKey          *int64                 `json:"incidentKey,omitempty"`
	Key                  *int64                 `json:"key,omitempty"`
	ProcessDefinitionKey *int64                 `json:"processDefinitionKey,omitempty"`
	ProcessInstanceKey   *int64                 `json:"processInstanceKey,omitempty"`
	StartDate            *string                `json:"startDate,omitempty"`
	State                *FlowNodeInstanceState `json:"state,omitempty"`
	TenantId             *string                `json:"tenantId,omitempty"`
	Type                 *FlowNodeInstanceType  `json:"type,omitempty"`
}

// FlowNodeInstanceState defines model for FlowNodeInstance.State.
type FlowNodeInstanceState string

// FlowNodeInstanceType defines model for FlowNodeInstance.Type.
type FlowNodeInstanceType string

// FlowNodeStatistics defines model for FlowNodeStatistics.
type FlowNodeStatistics struct {
	// Active The total number of active instances of the flow node
	Active *int64 `json:"active,omitempty"`

	// ActivityId The id of the flow node for which the results are aggregated
	ActivityId *string `json:"activityId,omitempty"`

	// Canceled The total number of canceled instances of the flow node
	Canceled *int64 `json:"canceled,omitempty"`

	// Completed The total number of completed instances of the flow node
	Completed *int64 `json:"completed,omitempty"`

	// Incidents The total number of incidents for the flow node
	Incidents *int64 `json:"incidents,omitempty"`
}

// Incident defines model for Incident.
type Incident struct {
	CreationTime         *string        `json:"creationTime,omitempty"`
	JobKey               *int64         `json:"jobKey,omitempty"`
	Key                  *int64         `json:"key,omitempty"`
	Message              *string        `json:"message,omitempty"`
	ProcessDefinitionKey *int64         `json:"processDefinitionKey,omitempty"`
	ProcessInstanceKey   *int64         `json:"processInstanceKey,omitempty"`
	State                *IncidentState `json:"state,omitempty"`
	TenantId             *string        `json:"tenantId,omitempty"`
	Type                 *IncidentType  `json:"type,omitempty"`
}

// IncidentState defines model for Incident.State.
type IncidentState string

// IncidentType defines model for Incident.Type.
type IncidentType string

// ProcessDefinition defines model for ProcessDefinition.
type ProcessDefinition struct {
	BpmnProcessId *string `json:"bpmnProcessId,omitempty"`
	Key           *int64  `json:"key,omitempty"`
	Name          *string `json:"name,omitempty"`
	TenantId      *string `json:"tenantId,omitempty"`
	Version       *int32  `json:"version,omitempty"`
	VersionTag    *string `json:"versionTag,omitempty"`
}

// ProcessInstance defines model for ProcessInstance.
type ProcessInstance struct {
	BpmnProcessId             *string               `json:"bpmnProcessId,omitempty"`
	EndDate                   *string               `json:"endDate,omitempty"`
	Incident                  *bool                 `json:"incident,omitempty"`
	Key                       *int64                `json:"key,omitempty"`
	ParentFlowNodeInstanceKey *int64                `json:"parentFlowNodeInstanceKey,omitempty"`
	ParentKey                 *int64                `json:"parentKey,omitempty"`
	ParentProcessInstanceKey  *ProcessInstance      `json:"parentProcessInstanceKey,omitempty"`
	ProcessDefinitionKey      *int64                `json:"processDefinitionKey,omitempty"`
	ProcessVersion            *int32                `json:"processVersion,omitempty"`
	ProcessVersionTag         *string               `json:"processVersionTag,omitempty"`
	StartDate                 *string               `json:"startDate,omitempty"`
	State                     *ProcessInstanceState `json:"state,omitempty"`
	TenantId                  *string               `json:"tenantId,omitempty"`
}

// ProcessInstanceState defines model for ProcessInstance.State.
type ProcessInstanceState string

// QueryDecisionDefinition defines model for QueryDecisionDefinition.
type QueryDecisionDefinition struct {
	Filter      *DecisionDefinition       `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryDecisionInstance defines model for QueryDecisionInstance.
type QueryDecisionInstance struct {
	Filter      *DecisionInstance         `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryDecisionRequirements defines model for QueryDecisionRequirements.
type QueryDecisionRequirements struct {
	Filter      *DecisionRequirements     `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryFlowNodeInstance defines model for QueryFlowNodeInstance.
type QueryFlowNodeInstance struct {
	Filter      *FlowNodeInstance         `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryIncident defines model for QueryIncident.
type QueryIncident struct {
	Filter      *Incident                 `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryProcessDefinition defines model for QueryProcessDefinition.
type QueryProcessDefinition struct {
	Filter      *ProcessDefinition        `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryProcessInstance defines model for QueryProcessInstance.
type QueryProcessInstance struct {
	Filter      *ProcessInstance          `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryVariable defines model for QueryVariable.
type QueryVariable struct {
	Filter      *Variable                 `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// ResultsDecisionDefinition defines model for ResultsDecisionDefinition.
type ResultsDecisionDefinition struct {
	Items      *[]DecisionDefinition     `json:"items,omitempty"`
	SortValues *[]map[string]interface{} `json:"sortValues,omitempty"`
	Total      *int64                    `json:"total,omitempty"`
}

// ResultsDecisionInstance defines model for ResultsDecisionInstance.
type ResultsDecisionInstance struct {
	Items      *[]DecisionInstance       `json:"items,omitempty"`
	SortValues *[]map[string]interface{} `json:"sortValues,omitempty"`
	Total      *int64                    `json:"total,omitempty"`
}

// ResultsDecisionRequirements defines model for ResultsDecisionRequirements.
type ResultsDecisionRequirements struct {
	Items      *[]DecisionRequirements   `json:"items,omitempty"`
	SortValues *[]map[string]interface{} `json:"sortValues,omitempty"`
	Total      *int64                    `json:"total,omitempty"`
}

// ResultsFlowNodeInstance defines model for ResultsFlowNodeInstance.
type ResultsFlowNodeInstance struct {
	Items      *[]FlowNodeInstance       `json:"items,omitempty"`
	SortValues *[]map[string]interface{} `json:"sortValues,omitempty"`
	Total      *int64                    `json:"total,omitempty"`
}

// ResultsIncident defines model for ResultsIncident.
type ResultsIncident struct {
	Items      *[]Incident               `json:"items,omitempty"`
	SortValues *[]map[string]interface{} `json:"sortValues,omitempty"`
	Total      *int64                    `json:"total,omitempty"`
}

// ResultsProcessDefinition defines model for ResultsProcessDefinition.
type ResultsProcessDefinition struct {
	Items      *[]ProcessDefinition      `json:"items,omitempty"`
	SortValues *[]map[string]interface{} `json:"sortValues,omitempty"`
	Total      *int64                    `json:"total,omitempty"`
}

// ResultsProcessInstance defines model for ResultsProcessInstance.
type ResultsProcessInstance struct {
	Items      *[]ProcessInstance        `json:"items,omitempty"`
	SortValues *[]map[string]interface{} `json:"sortValues,omitempty"`
	Total      *int64                    `json:"total,omitempty"`
}

// ResultsVariable defines model for ResultsVariable.
type ResultsVariable struct {
	Items      *[]Variable               `json:"items,omitempty"`
	SortValues *[]map[string]interface{} `json:"sortValues,omitempty"`
	Total      *int64                    `json:"total,omitempty"`
}

// Sort defines model for Sort.
type Sort struct {
	Field *string    `json:"field,omitempty"`
	Order *SortOrder `json:"order,omitempty"`
}

// SortOrder defines model for Sort.Order.
type SortOrder string

// Variable defines model for Variable.
type Variable struct {
	Key                *int64  `json:"key,omitempty"`
	Name               *string `json:"name,omitempty"`
	ProcessInstanceKey *int64  `json:"processInstanceKey,omitempty"`
	ScopeKey           *int64  `json:"scopeKey,omitempty"`
	TenantId           *string `json:"tenantId,omitempty"`
	Truncated          *bool   `json:"truncated,omitempty"`
	Value              *string `json:"value,omitempty"`
}

// Search7JSONRequestBody defines body for Search7 for application/json ContentType.
type Search7JSONRequestBody = QueryDecisionDefinition

// Search6JSONRequestBody defines body for Search6 for application/json ContentType.
type Search6JSONRequestBody = QueryDecisionInstance

// Search5JSONRequestBody defines body for Search5 for application/json ContentType.
type Search5JSONRequestBody = QueryDecisionRequirements

// Search4JSONRequestBody defines body for Search4 for application/json ContentType.
type Search4JSONRequestBody = QueryFlowNodeInstance

// Search3JSONRequestBody defines body for Search3 for application/json ContentType.
type Search3JSONRequestBody = QueryIncident

// Search2JSONRequestBody defines body for Search2 for application/json ContentType.
type Search2JSONRequestBody = QueryProcessDefinition

// Search1JSONRequestBody defines body for Search1 for application/json ContentType.
type Search1JSONRequestBody = QueryProcessInstance

// SearchJSONRequestBody defines body for Search for application/json ContentType.
type SearchJSONRequestBody = QueryVariable

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Search7WithBody request with any body
	Search7WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Search7(ctx context.Context, body Search7JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ByKey6 request
	ByKey6(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search6WithBody request with any body
	Search6WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Search6(ctx context.Context, body Search6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ById request
	ById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search5WithBody request with any body
	Search5WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Search5(ctx context.Context, body Search5JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ByKey5 request
	ByKey5(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// XmlByKey1 request
	XmlByKey1(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search4WithBody request with any body
	Search4WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Search4(ctx context.Context, body Search4JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ByKey4 request
	ByKey4(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search3WithBody request with any body
	Search3WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Search3(ctx context.Context, body Search3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ByKey3 request
	ByKey3(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search2WithBody request with any body
	Search2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Search2(ctx context.Context, body Search2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ByKey2 request
	ByKey2(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// XmlByKey request
	XmlByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search1WithBody request with any body
	Search1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Search1(ctx context.Context, body Search1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete request
	Delete(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ByKey1 request
	ByKey1(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SequenceFlowsByKey request
	SequenceFlowsByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatistics request
	GetStatistics(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchWithBody request with any body
	SearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Search(ctx context.Context, body SearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ByKey request
	ByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Search7WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch7RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search7(ctx context.Context, body Search7JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch7Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ByKey6(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByKey6Request(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search6WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch6RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search6(ctx context.Context, body Search6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch6Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search5WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch5RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search5(ctx context.Context, body Search5JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch5Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ByKey5(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByKey5Request(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) XmlByKey1(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewXmlByKey1Request(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search4WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch4RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search4(ctx context.Context, body Search4JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch4Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ByKey4(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByKey4Request(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search3WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch3RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search3(ctx context.Context, body Search3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch3Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ByKey3(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByKey3Request(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search2(ctx context.Context, body Search2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ByKey2(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByKey2Request(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) XmlByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewXmlByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search1(ctx context.Context, body Search1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ByKey1(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByKey1Request(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SequenceFlowsByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSequenceFlowsByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatistics(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, body SearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSearch7Request calls the generic Search7 builder with application/json body
func NewSearch7Request(server string, body Search7JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearch7RequestWithBody(server, "application/json", bodyReader)
}

// NewSearch7RequestWithBody generates requests for Search7 with any type of body
func NewSearch7RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/decision-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewByKey6Request generates requests for ByKey6
func NewByKey6Request(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/decision-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearch6Request calls the generic Search6 builder with application/json body
func NewSearch6Request(server string, body Search6JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearch6RequestWithBody(server, "application/json", bodyReader)
}

// NewSearch6RequestWithBody generates requests for Search6 with any type of body
func NewSearch6RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/decision-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewByIdRequest generates requests for ById
func NewByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/decision-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearch5Request calls the generic Search5 builder with application/json body
func NewSearch5Request(server string, body Search5JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearch5RequestWithBody(server, "application/json", bodyReader)
}

// NewSearch5RequestWithBody generates requests for Search5 with any type of body
func NewSearch5RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/drd/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewByKey5Request generates requests for ByKey5
func NewByKey5Request(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/drd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewXmlByKey1Request generates requests for XmlByKey1
func NewXmlByKey1Request(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/drd/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearch4Request calls the generic Search4 builder with application/json body
func NewSearch4Request(server string, body Search4JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearch4RequestWithBody(server, "application/json", bodyReader)
}

// NewSearch4RequestWithBody generates requests for Search4 with any type of body
func NewSearch4RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/flownode-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewByKey4Request generates requests for ByKey4
func NewByKey4Request(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/flownode-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearch3Request calls the generic Search3 builder with application/json body
func NewSearch3Request(server string, body Search3JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearch3RequestWithBody(server, "application/json", bodyReader)
}

// NewSearch3RequestWithBody generates requests for Search3 with any type of body
func NewSearch3RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/incidents/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewByKey3Request generates requests for ByKey3
func NewByKey3Request(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/incidents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearch2Request calls the generic Search2 builder with application/json body
func NewSearch2Request(server string, body Search2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearch2RequestWithBody(server, "application/json", bodyReader)
}

// NewSearch2RequestWithBody generates requests for Search2 with any type of body
func NewSearch2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewByKey2Request generates requests for ByKey2
func NewByKey2Request(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewXmlByKeyRequest generates requests for XmlByKey
func NewXmlByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-definitions/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearch1Request calls the generic Search1 builder with application/json body
func NewSearch1Request(server string, body Search1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearch1RequestWithBody(server, "application/json", bodyReader)
}

// NewSearch1RequestWithBody generates requests for Search1 with any type of body
func NewSearch1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRequest generates requests for Delete
func NewDeleteRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewByKey1Request generates requests for ByKey1
func NewByKey1Request(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSequenceFlowsByKeyRequest generates requests for SequenceFlowsByKey
func NewSequenceFlowsByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/%s/sequence-flows", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsRequest generates requests for GetStatistics
func NewGetStatisticsRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/%s/statistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRequest calls the generic Search builder with application/json body
func NewSearchRequest(server string, body SearchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchRequestWithBody generates requests for Search with any type of body
func NewSearchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/variables/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewByKeyRequest generates requests for ByKey
func NewByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Search7WithBodyWithResponse request with any body
	Search7WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search7Response, error)

	Search7WithResponse(ctx context.Context, body Search7JSONRequestBody, reqEditors ...RequestEditorFn) (*Search7Response, error)

	// ByKey6WithResponse request
	ByKey6WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey6Response, error)

	// Search6WithBodyWithResponse request with any body
	Search6WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search6Response, error)

	Search6WithResponse(ctx context.Context, body Search6JSONRequestBody, reqEditors ...RequestEditorFn) (*Search6Response, error)

	// ByIdWithResponse request
	ByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ByIdResponse, error)

	// Search5WithBodyWithResponse request with any body
	Search5WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search5Response, error)

	Search5WithResponse(ctx context.Context, body Search5JSONRequestBody, reqEditors ...RequestEditorFn) (*Search5Response, error)

	// ByKey5WithResponse request
	ByKey5WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey5Response, error)

	// XmlByKey1WithResponse request
	XmlByKey1WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*XmlByKey1Response, error)

	// Search4WithBodyWithResponse request with any body
	Search4WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search4Response, error)

	Search4WithResponse(ctx context.Context, body Search4JSONRequestBody, reqEditors ...RequestEditorFn) (*Search4Response, error)

	// ByKey4WithResponse request
	ByKey4WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey4Response, error)

	// Search3WithBodyWithResponse request with any body
	Search3WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search3Response, error)

	Search3WithResponse(ctx context.Context, body Search3JSONRequestBody, reqEditors ...RequestEditorFn) (*Search3Response, error)

	// ByKey3WithResponse request
	ByKey3WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey3Response, error)

	// Search2WithBodyWithResponse request with any body
	Search2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search2Response, error)

	Search2WithResponse(ctx context.Context, body Search2JSONRequestBody, reqEditors ...RequestEditorFn) (*Search2Response, error)

	// ByKey2WithResponse request
	ByKey2WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey2Response, error)

	// XmlByKeyWithResponse request
	XmlByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*XmlByKeyResponse, error)

	// Search1WithBodyWithResponse request with any body
	Search1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search1Response, error)

	Search1WithResponse(ctx context.Context, body Search1JSONRequestBody, reqEditors ...RequestEditorFn) (*Search1Response, error)

	// DeleteWithResponse request
	DeleteWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*DeleteResponse, error)

	// ByKey1WithResponse request
	ByKey1WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey1Response, error)

	// SequenceFlowsByKeyWithResponse request
	SequenceFlowsByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*SequenceFlowsByKeyResponse, error)

	// GetStatisticsWithResponse request
	GetStatisticsWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetStatisticsResponse, error)

	// SearchWithBodyWithResponse request with any body
	SearchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	SearchWithResponse(ctx context.Context, body SearchJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// ByKeyWithResponse request
	ByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKeyResponse, error)
}

type Search7Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsDecisionDefinition
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r Search7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ByKey6Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionDefinition
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ByKey6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ByKey6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search6Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsDecisionInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r Search6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search5Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsDecisionRequirements
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r Search5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ByKey5Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionRequirements
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ByKey5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ByKey5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type XmlByKey1Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r XmlByKey1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r XmlByKey1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search4Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsFlowNodeInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r Search4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ByKey4Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *FlowNodeInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ByKey4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ByKey4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search3Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsIncident
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r Search3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ByKey3Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Incident
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ByKey3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ByKey3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search2Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsProcessDefinition
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r Search2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ByKey2Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinition
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ByKey2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ByKey2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type XmlByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r XmlByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r XmlByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search1Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsProcessInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r Search1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ChangeStatus
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ByKey1Response struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ByKey1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ByKey1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SequenceFlowsByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SequenceFlowsByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SequenceFlowsByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]FlowNodeStatistics
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsVariable
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Variable
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// Search7WithBodyWithResponse request with arbitrary body returning *Search7Response
func (c *ClientWithResponses) Search7WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search7Response, error) {
	rsp, err := c.Search7WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch7Response(rsp)
}

func (c *ClientWithResponses) Search7WithResponse(ctx context.Context, body Search7JSONRequestBody, reqEditors ...RequestEditorFn) (*Search7Response, error) {
	rsp, err := c.Search7(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch7Response(rsp)
}

// ByKey6WithResponse request returning *ByKey6Response
func (c *ClientWithResponses) ByKey6WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey6Response, error) {
	rsp, err := c.ByKey6(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseByKey6Response(rsp)
}

// Search6WithBodyWithResponse request with arbitrary body returning *Search6Response
func (c *ClientWithResponses) Search6WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search6Response, error) {
	rsp, err := c.Search6WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch6Response(rsp)
}

func (c *ClientWithResponses) Search6WithResponse(ctx context.Context, body Search6JSONRequestBody, reqEditors ...RequestEditorFn) (*Search6Response, error) {
	rsp, err := c.Search6(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch6Response(rsp)
}

// ByIdWithResponse request returning *ByIdResponse
func (c *ClientWithResponses) ByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ByIdResponse, error) {
	rsp, err := c.ById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseByIdResponse(rsp)
}

// Search5WithBodyWithResponse request with arbitrary body returning *Search5Response
func (c *ClientWithResponses) Search5WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search5Response, error) {
	rsp, err := c.Search5WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch5Response(rsp)
}

func (c *ClientWithResponses) Search5WithResponse(ctx context.Context, body Search5JSONRequestBody, reqEditors ...RequestEditorFn) (*Search5Response, error) {
	rsp, err := c.Search5(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch5Response(rsp)
}

// ByKey5WithResponse request returning *ByKey5Response
func (c *ClientWithResponses) ByKey5WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey5Response, error) {
	rsp, err := c.ByKey5(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseByKey5Response(rsp)
}

// XmlByKey1WithResponse request returning *XmlByKey1Response
func (c *ClientWithResponses) XmlByKey1WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*XmlByKey1Response, error) {
	rsp, err := c.XmlByKey1(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseXmlByKey1Response(rsp)
}

// Search4WithBodyWithResponse request with arbitrary body returning *Search4Response
func (c *ClientWithResponses) Search4WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search4Response, error) {
	rsp, err := c.Search4WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch4Response(rsp)
}

func (c *ClientWithResponses) Search4WithResponse(ctx context.Context, body Search4JSONRequestBody, reqEditors ...RequestEditorFn) (*Search4Response, error) {
	rsp, err := c.Search4(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch4Response(rsp)
}

// ByKey4WithResponse request returning *ByKey4Response
func (c *ClientWithResponses) ByKey4WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey4Response, error) {
	rsp, err := c.ByKey4(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseByKey4Response(rsp)
}

// Search3WithBodyWithResponse request with arbitrary body returning *Search3Response
func (c *ClientWithResponses) Search3WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search3Response, error) {
	rsp, err := c.Search3WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch3Response(rsp)
}

func (c *ClientWithResponses) Search3WithResponse(ctx context.Context, body Search3JSONRequestBody, reqEditors ...RequestEditorFn) (*Search3Response, error) {
	rsp, err := c.Search3(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch3Response(rsp)
}

// ByKey3WithResponse request returning *ByKey3Response
func (c *ClientWithResponses) ByKey3WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey3Response, error) {
	rsp, err := c.ByKey3(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseByKey3Response(rsp)
}

// Search2WithBodyWithResponse request with arbitrary body returning *Search2Response
func (c *ClientWithResponses) Search2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search2Response, error) {
	rsp, err := c.Search2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch2Response(rsp)
}

func (c *ClientWithResponses) Search2WithResponse(ctx context.Context, body Search2JSONRequestBody, reqEditors ...RequestEditorFn) (*Search2Response, error) {
	rsp, err := c.Search2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch2Response(rsp)
}

// ByKey2WithResponse request returning *ByKey2Response
func (c *ClientWithResponses) ByKey2WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey2Response, error) {
	rsp, err := c.ByKey2(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseByKey2Response(rsp)
}

// XmlByKeyWithResponse request returning *XmlByKeyResponse
func (c *ClientWithResponses) XmlByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*XmlByKeyResponse, error) {
	rsp, err := c.XmlByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseXmlByKeyResponse(rsp)
}

// Search1WithBodyWithResponse request with arbitrary body returning *Search1Response
func (c *ClientWithResponses) Search1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Search1Response, error) {
	rsp, err := c.Search1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch1Response(rsp)
}

func (c *ClientWithResponses) Search1WithResponse(ctx context.Context, body Search1JSONRequestBody, reqEditors ...RequestEditorFn) (*Search1Response, error) {
	rsp, err := c.Search1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch1Response(rsp)
}

// DeleteWithResponse request returning *DeleteResponse
func (c *ClientWithResponses) DeleteWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*DeleteResponse, error) {
	rsp, err := c.Delete(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResponse(rsp)
}

// ByKey1WithResponse request returning *ByKey1Response
func (c *ClientWithResponses) ByKey1WithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKey1Response, error) {
	rsp, err := c.ByKey1(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseByKey1Response(rsp)
}

// SequenceFlowsByKeyWithResponse request returning *SequenceFlowsByKeyResponse
func (c *ClientWithResponses) SequenceFlowsByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*SequenceFlowsByKeyResponse, error) {
	rsp, err := c.SequenceFlowsByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSequenceFlowsByKeyResponse(rsp)
}

// GetStatisticsWithResponse request returning *GetStatisticsResponse
func (c *ClientWithResponses) GetStatisticsWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetStatisticsResponse, error) {
	rsp, err := c.GetStatistics(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsResponse(rsp)
}

// SearchWithBodyWithResponse request with arbitrary body returning *SearchResponse
func (c *ClientWithResponses) SearchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.SearchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, body SearchJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// ByKeyWithResponse request returning *ByKeyResponse
func (c *ClientWithResponses) ByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*ByKeyResponse, error) {
	rsp, err := c.ByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseByKeyResponse(rsp)
}

// ParseSearch7Response parses an HTTP response from a Search7WithResponse call
func ParseSearch7Response(rsp *http.Response) (*Search7Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsDecisionDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseByKey6Response parses an HTTP response from a ByKey6WithResponse call
func ParseByKey6Response(rsp *http.Response) (*ByKey6Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ByKey6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearch6Response parses an HTTP response from a Search6WithResponse call
func ParseSearch6Response(rsp *http.Response) (*Search6Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsDecisionInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseByIdResponse parses an HTTP response from a ByIdWithResponse call
func ParseByIdResponse(rsp *http.Response) (*ByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearch5Response parses an HTTP response from a Search5WithResponse call
func ParseSearch5Response(rsp *http.Response) (*Search5Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsDecisionRequirements
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseByKey5Response parses an HTTP response from a ByKey5WithResponse call
func ParseByKey5Response(rsp *http.Response) (*ByKey5Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ByKey5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionRequirements
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseXmlByKey1Response parses an HTTP response from a XmlByKey1WithResponse call
func ParseXmlByKey1Response(rsp *http.Response) (*XmlByKey1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &XmlByKey1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseSearch4Response parses an HTTP response from a Search4WithResponse call
func ParseSearch4Response(rsp *http.Response) (*Search4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsFlowNodeInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseByKey4Response parses an HTTP response from a ByKey4WithResponse call
func ParseByKey4Response(rsp *http.Response) (*ByKey4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ByKey4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlowNodeInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearch3Response parses an HTTP response from a Search3WithResponse call
func ParseSearch3Response(rsp *http.Response) (*Search3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsIncident
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseByKey3Response parses an HTTP response from a ByKey3WithResponse call
func ParseByKey3Response(rsp *http.Response) (*ByKey3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ByKey3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Incident
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearch2Response parses an HTTP response from a Search2WithResponse call
func ParseSearch2Response(rsp *http.Response) (*Search2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsProcessDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseByKey2Response parses an HTTP response from a ByKey2WithResponse call
func ParseByKey2Response(rsp *http.Response) (*ByKey2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ByKey2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseXmlByKeyResponse parses an HTTP response from a XmlByKeyWithResponse call
func ParseXmlByKeyResponse(rsp *http.Response) (*XmlByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &XmlByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseSearch1Response parses an HTTP response from a Search1WithResponse call
func ParseSearch1Response(rsp *http.Response) (*Search1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsProcessInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteResponse parses an HTTP response from a DeleteWithResponse call
func ParseDeleteResponse(rsp *http.Response) (*DeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChangeStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseByKey1Response parses an HTTP response from a ByKey1WithResponse call
func ParseByKey1Response(rsp *http.Response) (*ByKey1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ByKey1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSequenceFlowsByKeyResponse parses an HTTP response from a SequenceFlowsByKeyWithResponse call
func ParseSequenceFlowsByKeyResponse(rsp *http.Response) (*SequenceFlowsByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SequenceFlowsByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetStatisticsResponse parses an HTTP response from a GetStatisticsWithResponse call
func ParseGetStatisticsResponse(rsp *http.Response) (*GetStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FlowNodeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseByKeyResponse parses an HTTP response from a ByKeyWithResponse call
func ParseByKeyResponse(rsp *http.Response) (*ByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Variable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}
