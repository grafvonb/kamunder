// Package tasklist provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package tasklist

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	Bearer_keyScopes = "bearer_key.Scopes"
	CookieScopes     = "cookie.Scopes"
)

// Defines values for TaskByVariablesOperator.
const (
	Eq TaskByVariablesOperator = "eq"
)

// Defines values for TaskOrderByField.
const (
	CompletionTime TaskOrderByField = "completionTime"
	CreationTime   TaskOrderByField = "creationTime"
	DueDate        TaskOrderByField = "dueDate"
	FollowUpDate   TaskOrderByField = "followUpDate"
	Priority       TaskOrderByField = "priority"
)

// Defines values for TaskOrderByOrder.
const (
	ASC  TaskOrderByOrder = "ASC"
	DESC TaskOrderByOrder = "DESC"
)

// Defines values for TaskResponseImplementation.
const (
	TaskResponseImplementationJOBWORKER     TaskResponseImplementation = "JOB_WORKER"
	TaskResponseImplementationZEEBEUSERTASK TaskResponseImplementation = "ZEEBE_USER_TASK"
)

// Defines values for TaskResponseTaskState.
const (
	TaskResponseTaskStateCANCELED  TaskResponseTaskState = "CANCELED"
	TaskResponseTaskStateCOMPLETED TaskResponseTaskState = "COMPLETED"
	TaskResponseTaskStateCREATED   TaskResponseTaskState = "CREATED"
	TaskResponseTaskStateFAILED    TaskResponseTaskState = "FAILED"
)

// Defines values for TaskSearchRequestImplementation.
const (
	TaskSearchRequestImplementationJOBWORKER     TaskSearchRequestImplementation = "JOB_WORKER"
	TaskSearchRequestImplementationZEEBEUSERTASK TaskSearchRequestImplementation = "ZEEBE_USER_TASK"
)

// Defines values for TaskSearchRequestState.
const (
	TaskSearchRequestStateCANCELED  TaskSearchRequestState = "CANCELED"
	TaskSearchRequestStateCOMPLETED TaskSearchRequestState = "COMPLETED"
	TaskSearchRequestStateCREATED   TaskSearchRequestState = "CREATED"
	TaskSearchRequestStateFAILED    TaskSearchRequestState = "FAILED"
)

// Defines values for TaskSearchResponseImplementation.
const (
	JOBWORKER     TaskSearchResponseImplementation = "JOB_WORKER"
	ZEEBEUSERTASK TaskSearchResponseImplementation = "ZEEBE_USER_TASK"
)

// Defines values for TaskSearchResponseTaskState.
const (
	CANCELED  TaskSearchResponseTaskState = "CANCELED"
	COMPLETED TaskSearchResponseTaskState = "COMPLETED"
	CREATED   TaskSearchResponseTaskState = "CREATED"
	FAILED    TaskSearchResponseTaskState = "FAILED"
)

// DateFilter A range of due dates for the tasks to search for.
type DateFilter struct {
	// From Start date range to search from in date-time format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard.
	From *time.Time `json:"from,omitempty"`

	// To End date range to search to in date-time format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard.
	To *time.Time `json:"to,omitempty"`
}

// DraftSearchVariableValue The draft value of the variable.
type DraftSearchVariableValue struct {
	// IsValueTruncated Does the `previewValue` contain the truncated value or full value?
	IsValueTruncated *bool `json:"isValueTruncated,omitempty"`

	// PreviewValue A preview of the variable's value. Limited in size.
	PreviewValue *string `json:"previewValue,omitempty"`

	// Value The value of the variable.
	Value *string `json:"value,omitempty"`
}

// DraftVariableValue The draft value of the variable
type DraftVariableValue struct {
	Value *string `json:"value,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Instance Error instance UUID for lookup (e.g., in log messages).
	Instance *string `json:"instance,omitempty"`

	// Message A string that provides a brief description of the error that occurred.
	Message *string `json:"message,omitempty"`

	// Status An integer that represents the HTTP status code of the error response. For example, 400 indicates a 'Bad Request' error, 404 indicates a 'Not Found' error, and so on.
	Status *int32 `json:"status,omitempty"`
}

// FormResponse defines model for FormResponse.
type FormResponse struct {
	// Id The unique identifier of the embedded form within one process.
	Id *string `json:"id,omitempty"`

	// IsDeleted Indicates whether the deployed form is deleted or not on Zeebe. This field is false by default, in the case of an embedded form.
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// ProcessDefinitionKey Reference to process definition (renamed equivalent of `Form.processDefinitionId` field).
	ProcessDefinitionKey *string `json:"processDefinitionKey,omitempty"`

	// Schema The form content.
	Schema *string `json:"schema,omitempty"`

	// TenantId The tenant ID associated with the form.
	TenantId *string `json:"tenantId,omitempty"`

	// Title The title of the form.
	Title *string `json:"title,omitempty"`

	// Version The version field is null in the case of an embedded form, while it represents the deployed form's version in other scenarios.
	Version *int64 `json:"version,omitempty"`
}

// IncludeVariable defines model for IncludeVariable.
type IncludeVariable struct {
	// AlwaysReturnFullValue Always return the full value of the variable?
	AlwaysReturnFullValue *bool `json:"alwaysReturnFullValue,omitempty"`

	// Name The name of the variable.
	Name *string `json:"name,omitempty"`
}

// SaveVariablesRequest defines model for SaveVariablesRequest.
type SaveVariablesRequest struct {
	// Variables Variables to update or add to the task.
	Variables *[]VariableInputDTO `json:"variables,omitempty"`
}

// TaskAssignRequest Request params used to assign the task to assignee or current user.
type TaskAssignRequest struct {
	// AllowOverrideAssignment When `true` the task that is already assigned may be assigned again. Otherwise the task
	// must be first unassigned and only then assigned again.
	AllowOverrideAssignment *bool `json:"allowOverrideAssignment,omitempty"`

	// Assignee When using a JWT token, the assignee parameter is NOT optional when called directly from the API.
	// The system will not be able to detect the assignee from the JWT token, therefore the assignee parameter needs to be
	// explicitly passed in this instance.
	Assignee *string `json:"assignee,omitempty"`
}

// TaskByVariables defines model for TaskByVariables.
type TaskByVariables struct {
	// Name The name of the variable.
	Name *string `json:"name,omitempty"`

	// Operator The comparison operator to use for the variable.<br/>* `eq`: Equals
	Operator *TaskByVariablesOperator `json:"operator,omitempty"`

	// Value The value of the variable. When specifying the variable value, it's crucial to maintain consistency with JSON values (serialization for the complex objects such as list) and ensure that strings remain appropriately formatted.
	Value *string `json:"value,omitempty"`
}

// TaskByVariablesOperator The comparison operator to use for the variable.<br/>* `eq`: Equals
type TaskByVariablesOperator string

// TaskCompleteRequest Request object with variables to update or add to task during the task completion.
type TaskCompleteRequest struct {
	// Variables Variables to update or add to task during the task completion
	Variables *[]VariableInputDTO `json:"variables,omitempty"`
}

// TaskOrderBy Sort results by a specific field.
type TaskOrderBy struct {
	Field *TaskOrderByField `json:"field,omitempty"`

	// Order * `ASC`: Ascending<br/>* `DESC`: Descending
	Order *TaskOrderByOrder `json:"order,omitempty"`
}

// TaskOrderByField defines model for TaskOrderBy.Field.
type TaskOrderByField string

// TaskOrderByOrder * `ASC`: Ascending<br/>* `DESC`: Descending
type TaskOrderByOrder string

// TaskResponse defines model for TaskResponse.
type TaskResponse struct {
	// Assignee The username/id of who is assigned to the task.
	Assignee *string `json:"assignee,omitempty"`

	// CandidateGroups The candidate groups for the task.
	CandidateGroups *[]string `json:"candidateGroups,omitempty"`

	// CandidateUsers The candidate users for the task.
	CandidateUsers *[]string `json:"candidateUsers,omitempty"`

	// CompletionDate When was the task completed (renamed equivalent of `Task.completionTime` field).
	CompletionDate *string `json:"completionDate,omitempty"`

	// CreationDate When was the task created (renamed equivalent of `Task.creationTime` field).
	CreationDate *string `json:"creationDate,omitempty"`

	// DueDate The due date for the task.
	DueDate *time.Time `json:"dueDate,omitempty"`

	// FollowUpDate The follow-up date for the task.
	FollowUpDate *time.Time `json:"followUpDate,omitempty"`

	// FormId Reference to the ID of a deployed form. If the form is not deployed, this property is null.
	FormId *string `json:"formId,omitempty"`

	// FormKey Reference to the task form.
	FormKey *string `json:"formKey,omitempty"`

	// FormVersion Reference to the version of a deployed form. If the form is not deployed, this property is null.
	FormVersion *int64 `json:"formVersion,omitempty"`

	// Id The unique identifier of the task.
	Id             *string                     `json:"id,omitempty"`
	Implementation *TaskResponseImplementation `json:"implementation,omitempty"`

	// IsFormEmbedded Is the form embedded for this task? If there is no form, this property is null.
	IsFormEmbedded *bool `json:"isFormEmbedded,omitempty"`

	// Name The name of the task.
	Name *string `json:"name,omitempty"`

	// Priority The priority of a user task. The higher the value the higher the priority. Applicable only for Zeebe user tasks.
	Priority *int `json:"priority,omitempty"`

	// ProcessDefinitionKey Reference to process definition (renamed equivalent of `Task.processDefinitionId` field).
	ProcessDefinitionKey *string `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey Reference to process instance id (renamed equivalent of `Task.processInstanceId` field).
	ProcessInstanceKey *string `json:"processInstanceKey,omitempty"`

	// ProcessName The name of the process.
	ProcessName *string `json:"processName,omitempty"`

	// TaskDefinitionId User task ID from the BPMN definition.
	TaskDefinitionId *string `json:"taskDefinitionId,omitempty"`

	// TaskState The state of the task.
	TaskState *TaskResponseTaskState `json:"taskState,omitempty"`

	// TenantId The tenant ID associated with the task.
	TenantId *string `json:"tenantId,omitempty"`
}

// TaskResponseImplementation defines model for TaskResponse.Implementation.
type TaskResponseImplementation string

// TaskResponseTaskState The state of the task.
type TaskResponseTaskState string

// TaskSearchRequest Request object to search tasks by provided params.
type TaskSearchRequest struct {
	// Assigned Are the tasks assigned?
	Assigned *bool `json:"assigned,omitempty"`

	// Assignee Who is assigned to the tasks?
	Assignee *string `json:"assignee,omitempty"`

	// Assignees The assignee is one of the given assignees.
	Assignees *[]string `json:"assignees,omitempty"`

	// CandidateGroup Given group is in candidate groups list.
	CandidateGroup *string `json:"candidateGroup,omitempty"`

	// CandidateGroups At least one of the given groups is in candidate groups list.
	CandidateGroups *[]string `json:"candidateGroups,omitempty"`

	// CandidateUser Given user is in candidate user list.
	CandidateUser *string `json:"candidateUser,omitempty"`

	// CandidateUsers At least one of the given users is in candidate user list.
	CandidateUsers *[]string `json:"candidateUsers,omitempty"`

	// DueDate A range of due dates for the tasks to search for.
	DueDate *DateFilter `json:"dueDate,omitempty"`

	// FollowUpDate A range of due dates for the tasks to search for.
	FollowUpDate   *DateFilter                      `json:"followUpDate,omitempty"`
	Implementation *TaskSearchRequestImplementation `json:"implementation,omitempty"`

	// IncludeVariables An array used to specify a list of variable names that should be included in the response when querying tasks.<br/>This field allows users to selectively retrieve specific variables associated with the tasks returned in the search results.
	IncludeVariables *[]IncludeVariable `json:"includeVariables,omitempty"`

	// PageSize Size of tasks page (default = 50).
	PageSize *int32 `json:"pageSize,omitempty"`

	// Priority Rules to filter out tasks by their priority. Applicable only for Zeebe user tasks.
	Priority *struct {
		Eq  *int `json:"eq,omitempty"`
		Gt  *int `json:"gt,omitempty"`
		Gte *int `json:"gte,omitempty"`
		Lt  *int `json:"lt,omitempty"`
		Lte *int `json:"lte,omitempty"`
	} `json:"priority,omitempty"`

	// ProcessDefinitionKey Reference to process definition (renamed equivalent of TaskQuery.processDefinitionId field).
	ProcessDefinitionKey *string `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey Reference to process instance (renamed equivalent of TaskQuery.processInstanceId field)
	ProcessInstanceKey *string `json:"processInstanceKey,omitempty"`

	// SearchAfter Used to return a paginated result. Array of values that should be copied from sortValues of one of the tasks from the current search results page.<br/>It enables the API to return a page of tasks that directly follow the task identified by the provided values, with respect to the sorting order.
	SearchAfter *[]string `json:"searchAfter,omitempty"`

	// SearchAfterOrEqual Used to return a paginated result. Array of values that should be copied from sortValues of one of the tasks from the current search results page.<br/>It enables the API to return a page of tasks that directly follow or are equal to the task identified by the provided values, with respect to the sorting order.
	SearchAfterOrEqual *[]string `json:"searchAfterOrEqual,omitempty"`

	// SearchBefore Used to return a paginated result. Array of values that should be copied from sortValues of one of the tasks from the current search results page.<br/>It enables the API to return a page of tasks that directly precede the task identified by the provided values, with respect to the sorting order.
	SearchBefore *[]string `json:"searchBefore,omitempty"`

	// SearchBeforeOrEqual Used to return a paginated result. Array of values that should be copied from sortValues of one of the tasks from the current search results page.<br/>It enables the API to return a page of tasks that directly precede or are equal to the task identified by the provided values, with respect to the sorting order.
	SearchBeforeOrEqual *[]string `json:"searchBeforeOrEqual,omitempty"`

	// Sort An array of objects specifying the fields to sort the results by.
	Sort *[]TaskOrderBy `json:"sort,omitempty"`

	// State The state of the tasks.
	State *TaskSearchRequestState `json:"state,omitempty"`

	// TaskDefinitionId What's the BPMN flow node?
	TaskDefinitionId *string `json:"taskDefinitionId,omitempty"`

	// TaskVariables An array of filter clauses specifying the variables to filter for.<br/>If defined, the query returns only tasks to which all clauses apply.<br/>However, it's important to note that this filtering mechanism is<br/>designed to work exclusively with truncated variables. This means<br/>variables of a larger size are not compatible with this filter, and<br/>attempts to use them may result in inaccurate or incomplete query results.
	TaskVariables *[]TaskByVariables `json:"taskVariables,omitempty"`

	// TenantIds An array of Tenant IDs to filter tasks. When multi-tenancy is<br/>enabled, tasks associated with the specified tenant IDs are returned;<br/>if disabled, this parameter is ignored.
	TenantIds *[]string `json:"tenantIds,omitempty"`
}

// TaskSearchRequestImplementation defines model for TaskSearchRequest.Implementation.
type TaskSearchRequestImplementation string

// TaskSearchRequestState The state of the tasks.
type TaskSearchRequestState string

// TaskSearchResponse defines model for TaskSearchResponse.
type TaskSearchResponse struct {
	// Assignee The username/id of who is assigned to the task.
	Assignee *string `json:"assignee,omitempty"`

	// CandidateGroups The candidate groups for the task.
	CandidateGroups *[]string `json:"candidateGroups,omitempty"`

	// CandidateUsers The candidate users for the task.
	CandidateUsers *[]string `json:"candidateUsers,omitempty"`

	// CompletionDate When was the task completed (renamed equivalent of `Task.completionTime` field).
	CompletionDate *string `json:"completionDate,omitempty"`

	// CreationDate When was the task created (renamed equivalent of `Task.creationTime` field).
	CreationDate *string `json:"creationDate,omitempty"`

	// DueDate The due date for the task.
	DueDate *time.Time `json:"dueDate,omitempty"`

	// FollowUpDate The follow-up date for the task.
	FollowUpDate *time.Time `json:"followUpDate,omitempty"`

	// FormId Reference to the ID of a deployed form. If the form is not deployed, this property is null.
	FormId *string `json:"formId,omitempty"`

	// FormKey Reference to the task form.
	FormKey *string `json:"formKey,omitempty"`

	// FormVersion Reference to the version of a deployed form. If the form is not deployed, this property is null.
	FormVersion *int64 `json:"formVersion,omitempty"`

	// Id The unique identifier of the task.
	Id             *string                           `json:"id,omitempty"`
	Implementation *TaskSearchResponseImplementation `json:"implementation,omitempty"`

	// IsFirst A flag to show that the task is first in the current filter.
	IsFirst *bool `json:"isFirst,omitempty"`

	// IsFormEmbedded Is the form embedded for this task? If there is no form, this property is null.
	IsFormEmbedded *bool `json:"isFormEmbedded,omitempty"`

	// Name The name of the task.
	Name *string `json:"name,omitempty"`

	// Priority The priority of a user task. The higher the value the higher the priority. Applicable only for Zeebe user tasks.
	Priority *int `json:"priority,omitempty"`

	// ProcessDefinitionKey Reference to process definition (renamed equivalent of `Task.processDefinitionId` field).
	ProcessDefinitionKey *string `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey Reference to process instance id (renamed equivalent of `Task.processInstanceId` field).
	ProcessInstanceKey *string `json:"processInstanceKey,omitempty"`

	// ProcessName The name of the process.
	ProcessName *string `json:"processName,omitempty"`

	// SortValues Array of values to be copied into `TaskSearchRequest` to request for next or previous page of tasks.
	SortValues *[]string `json:"sortValues,omitempty"`

	// TaskDefinitionId User task ID from the BPMN definition.
	TaskDefinitionId *string `json:"taskDefinitionId,omitempty"`

	// TaskState The state of the task.
	TaskState *TaskSearchResponseTaskState `json:"taskState,omitempty"`

	// TenantId The tenant ID associated with the task.
	TenantId *string `json:"tenantId,omitempty"`

	// Variables An array of the task's variables. Only variables specified in `TaskSearchRequest.includeVariables` are returned. Note that a variable's draft value is not returned in `TaskSearchResponse`.
	Variables *[]VariableSearchResponse `json:"variables,omitempty"`
}

// TaskSearchResponseImplementation defines model for TaskSearchResponse.Implementation.
type TaskSearchResponseImplementation string

// TaskSearchResponseTaskState The state of the task.
type TaskSearchResponseTaskState string

// VariableInputDTO defines model for VariableInputDTO.
type VariableInputDTO struct {
	// Name The name of the variable.
	Name *string `json:"name,omitempty"`

	// Value The value of the variable. When specifying the variable value, it's crucial to maintain consistency with JSON values (serialization for the complex objects such as list) and ensure that strings remain appropriately formatted.
	Value *string `json:"value,omitempty"`
}

// VariableResponse defines model for VariableResponse.
type VariableResponse struct {
	// Draft The draft value of the variable
	Draft *DraftVariableValue `json:"draft,omitempty"`

	// Id The ID of the variable
	Id *string `json:"id,omitempty"`

	// Name The name of the variable
	Name *string `json:"name,omitempty"`

	// TenantId The tenant ID associated with the variable
	TenantId *string `json:"tenantId,omitempty"`

	// Value The full value of the variable
	Value *string `json:"value,omitempty"`
}

// VariableSearchResponse defines model for VariableSearchResponse.
type VariableSearchResponse struct {
	// Draft The draft value of the variable.
	Draft *DraftSearchVariableValue `json:"draft,omitempty"`

	// Id The unique identifier of the variable.
	Id *string `json:"id,omitempty"`

	// IsValueTruncated Does the `previewValue` contain the truncated value or full value?
	IsValueTruncated *bool `json:"isValueTruncated,omitempty"`

	// Name The name of the variable.
	Name *string `json:"name,omitempty"`

	// PreviewValue A preview of the variable's value. Limited in size.
	PreviewValue *string `json:"previewValue,omitempty"`

	// Value The value of the variable.
	Value *string `json:"value,omitempty"`
}

// VariablesSearchRequest Request object to search tasks variables by provided variable names.
type VariablesSearchRequest struct {
	// IncludeVariables An array of variable names that should be included in the response.
	IncludeVariables *[]IncludeVariable `json:"includeVariables,omitempty"`

	// VariableNames Names of variables to find.
	VariableNames *[]string `json:"variableNames,omitempty"`
}

// GetFormParams defines parameters for GetForm.
type GetFormParams struct {
	// ProcessDefinitionKey Reference to the process definition.
	ProcessDefinitionKey string `form:"processDefinitionKey" json:"processDefinitionKey"`

	// Version The version of the form. Valid only for deployed forms.
	Version *int64 `form:"version,omitempty" json:"version,omitempty"`
}

// SearchTasksJSONRequestBody defines body for SearchTasks for application/json ContentType.
type SearchTasksJSONRequestBody = TaskSearchRequest

// AssignTaskJSONRequestBody defines body for AssignTask for application/json ContentType.
type AssignTaskJSONRequestBody = TaskAssignRequest

// CompleteTaskJSONRequestBody defines body for CompleteTask for application/json ContentType.
type CompleteTaskJSONRequestBody = TaskCompleteRequest

// SaveDraftTaskVariablesJSONRequestBody defines body for SaveDraftTaskVariables for application/json ContentType.
type SaveDraftTaskVariablesJSONRequestBody = SaveVariablesRequest

// SearchTaskVariablesJSONRequestBody defines body for SearchTaskVariables for application/json ContentType.
type SearchTaskVariablesJSONRequestBody = VariablesSearchRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetForm request
	GetForm(ctx context.Context, formId string, params *GetFormParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTasksWithBody request with any body
	SearchTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchTasks(ctx context.Context, body SearchTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaskById request
	GetTaskById(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignTaskWithBody request with any body
	AssignTaskWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignTask(ctx context.Context, taskId string, body AssignTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteTaskWithBody request with any body
	CompleteTaskWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteTask(ctx context.Context, taskId string, body CompleteTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignTask request
	UnassignTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveDraftTaskVariablesWithBody request with any body
	SaveDraftTaskVariablesWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveDraftTaskVariables(ctx context.Context, taskId string, body SaveDraftTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTaskVariablesWithBody request with any body
	SearchTaskVariablesWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchTaskVariables(ctx context.Context, taskId string, body SearchTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariableById request
	GetVariableById(ctx context.Context, variableId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetForm(ctx context.Context, formId string, params *GetFormParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFormRequest(c.Server, formId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTasksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTasks(ctx context.Context, body SearchTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTasksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaskById(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaskByIdRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignTaskWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignTaskRequestWithBody(c.Server, taskId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignTask(ctx context.Context, taskId string, body AssignTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignTaskRequest(c.Server, taskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteTaskWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteTaskRequestWithBody(c.Server, taskId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteTask(ctx context.Context, taskId string, body CompleteTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteTaskRequest(c.Server, taskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignTaskRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveDraftTaskVariablesWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveDraftTaskVariablesRequestWithBody(c.Server, taskId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveDraftTaskVariables(ctx context.Context, taskId string, body SaveDraftTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveDraftTaskVariablesRequest(c.Server, taskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTaskVariablesWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTaskVariablesRequestWithBody(c.Server, taskId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTaskVariables(ctx context.Context, taskId string, body SearchTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTaskVariablesRequest(c.Server, taskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariableById(ctx context.Context, variableId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableByIdRequest(c.Server, variableId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetFormRequest generates requests for GetForm
func NewGetFormRequest(server string, formId string, params *GetFormParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "formId", runtime.ParamLocationPath, formId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/forms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processDefinitionKey", runtime.ParamLocationQuery, params.ProcessDefinitionKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchTasksRequest calls the generic SearchTasks builder with application/json body
func NewSearchTasksRequest(server string, body SearchTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchTasksRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchTasksRequestWithBody generates requests for SearchTasks with any type of body
func NewSearchTasksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTaskByIdRequest generates requests for GetTaskById
func NewGetTaskByIdRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignTaskRequest calls the generic AssignTask builder with application/json body
func NewAssignTaskRequest(server string, taskId string, body AssignTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignTaskRequestWithBody(server, taskId, "application/json", bodyReader)
}

// NewAssignTaskRequestWithBody generates requests for AssignTask with any type of body
func NewAssignTaskRequestWithBody(server string, taskId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s/assign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompleteTaskRequest calls the generic CompleteTask builder with application/json body
func NewCompleteTaskRequest(server string, taskId string, body CompleteTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteTaskRequestWithBody(server, taskId, "application/json", bodyReader)
}

// NewCompleteTaskRequestWithBody generates requests for CompleteTask with any type of body
func NewCompleteTaskRequestWithBody(server string, taskId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s/complete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignTaskRequest generates requests for UnassignTask
func NewUnassignTaskRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s/unassign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveDraftTaskVariablesRequest calls the generic SaveDraftTaskVariables builder with application/json body
func NewSaveDraftTaskVariablesRequest(server string, taskId string, body SaveDraftTaskVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveDraftTaskVariablesRequestWithBody(server, taskId, "application/json", bodyReader)
}

// NewSaveDraftTaskVariablesRequestWithBody generates requests for SaveDraftTaskVariables with any type of body
func NewSaveDraftTaskVariablesRequestWithBody(server string, taskId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s/variables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchTaskVariablesRequest calls the generic SearchTaskVariables builder with application/json body
func NewSearchTaskVariablesRequest(server string, taskId string, body SearchTaskVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchTaskVariablesRequestWithBody(server, taskId, "application/json", bodyReader)
}

// NewSearchTaskVariablesRequestWithBody generates requests for SearchTaskVariables with any type of body
func NewSearchTaskVariablesRequestWithBody(server string, taskId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s/variables/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVariableByIdRequest generates requests for GetVariableById
func NewGetVariableByIdRequest(server string, variableId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableId", runtime.ParamLocationPath, variableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetFormWithResponse request
	GetFormWithResponse(ctx context.Context, formId string, params *GetFormParams, reqEditors ...RequestEditorFn) (*GetFormResponse, error)

	// SearchTasksWithBodyWithResponse request with any body
	SearchTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTasksResponse, error)

	SearchTasksWithResponse(ctx context.Context, body SearchTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTasksResponse, error)

	// GetTaskByIdWithResponse request
	GetTaskByIdWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetTaskByIdResponse, error)

	// AssignTaskWithBodyWithResponse request with any body
	AssignTaskWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignTaskResponse, error)

	AssignTaskWithResponse(ctx context.Context, taskId string, body AssignTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignTaskResponse, error)

	// CompleteTaskWithBodyWithResponse request with any body
	CompleteTaskWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteTaskResponse, error)

	CompleteTaskWithResponse(ctx context.Context, taskId string, body CompleteTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteTaskResponse, error)

	// UnassignTaskWithResponse request
	UnassignTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*UnassignTaskResponse, error)

	// SaveDraftTaskVariablesWithBodyWithResponse request with any body
	SaveDraftTaskVariablesWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveDraftTaskVariablesResponse, error)

	SaveDraftTaskVariablesWithResponse(ctx context.Context, taskId string, body SaveDraftTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveDraftTaskVariablesResponse, error)

	// SearchTaskVariablesWithBodyWithResponse request with any body
	SearchTaskVariablesWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTaskVariablesResponse, error)

	SearchTaskVariablesWithResponse(ctx context.Context, taskId string, body SearchTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTaskVariablesResponse, error)

	// GetVariableByIdWithResponse request
	GetVariableByIdWithResponse(ctx context.Context, variableId string, reqEditors ...RequestEditorFn) (*GetVariableByIdResponse, error)
}

type GetFormResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *FormResponse
	ApplicationproblemJSON404 *Error
}

// Status returns HTTPResponse.Status
func (r GetFormResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFormResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTasksResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]TaskSearchResponse
	ApplicationproblemJSON400 *Error
}

// Status returns HTTPResponse.Status
func (r SearchTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaskByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TaskResponse
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
}

// Status returns HTTPResponse.Status
func (r GetTaskByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaskByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TaskResponse
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
}

// Status returns HTTPResponse.Status
func (r AssignTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TaskResponse
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
}

// Status returns HTTPResponse.Status
func (r CompleteTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TaskResponse
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
}

// Status returns HTTPResponse.Status
func (r UnassignTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveDraftTaskVariablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SaveDraftTaskVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveDraftTaskVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTaskVariablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]VariableSearchResponse
	ApplicationproblemJSON404 *Error
}

// Status returns HTTPResponse.Status
func (r SearchTaskVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTaskVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VariableResponse
	ApplicationproblemJSON404 *Error
}

// Status returns HTTPResponse.Status
func (r GetVariableByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetFormWithResponse request returning *GetFormResponse
func (c *ClientWithResponses) GetFormWithResponse(ctx context.Context, formId string, params *GetFormParams, reqEditors ...RequestEditorFn) (*GetFormResponse, error) {
	rsp, err := c.GetForm(ctx, formId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFormResponse(rsp)
}

// SearchTasksWithBodyWithResponse request with arbitrary body returning *SearchTasksResponse
func (c *ClientWithResponses) SearchTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTasksResponse, error) {
	rsp, err := c.SearchTasksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTasksResponse(rsp)
}

func (c *ClientWithResponses) SearchTasksWithResponse(ctx context.Context, body SearchTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTasksResponse, error) {
	rsp, err := c.SearchTasks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTasksResponse(rsp)
}

// GetTaskByIdWithResponse request returning *GetTaskByIdResponse
func (c *ClientWithResponses) GetTaskByIdWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetTaskByIdResponse, error) {
	rsp, err := c.GetTaskById(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaskByIdResponse(rsp)
}

// AssignTaskWithBodyWithResponse request with arbitrary body returning *AssignTaskResponse
func (c *ClientWithResponses) AssignTaskWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignTaskResponse, error) {
	rsp, err := c.AssignTaskWithBody(ctx, taskId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignTaskResponse(rsp)
}

func (c *ClientWithResponses) AssignTaskWithResponse(ctx context.Context, taskId string, body AssignTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignTaskResponse, error) {
	rsp, err := c.AssignTask(ctx, taskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignTaskResponse(rsp)
}

// CompleteTaskWithBodyWithResponse request with arbitrary body returning *CompleteTaskResponse
func (c *ClientWithResponses) CompleteTaskWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteTaskResponse, error) {
	rsp, err := c.CompleteTaskWithBody(ctx, taskId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteTaskResponse(rsp)
}

func (c *ClientWithResponses) CompleteTaskWithResponse(ctx context.Context, taskId string, body CompleteTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteTaskResponse, error) {
	rsp, err := c.CompleteTask(ctx, taskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteTaskResponse(rsp)
}

// UnassignTaskWithResponse request returning *UnassignTaskResponse
func (c *ClientWithResponses) UnassignTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*UnassignTaskResponse, error) {
	rsp, err := c.UnassignTask(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignTaskResponse(rsp)
}

// SaveDraftTaskVariablesWithBodyWithResponse request with arbitrary body returning *SaveDraftTaskVariablesResponse
func (c *ClientWithResponses) SaveDraftTaskVariablesWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveDraftTaskVariablesResponse, error) {
	rsp, err := c.SaveDraftTaskVariablesWithBody(ctx, taskId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveDraftTaskVariablesResponse(rsp)
}

func (c *ClientWithResponses) SaveDraftTaskVariablesWithResponse(ctx context.Context, taskId string, body SaveDraftTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveDraftTaskVariablesResponse, error) {
	rsp, err := c.SaveDraftTaskVariables(ctx, taskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveDraftTaskVariablesResponse(rsp)
}

// SearchTaskVariablesWithBodyWithResponse request with arbitrary body returning *SearchTaskVariablesResponse
func (c *ClientWithResponses) SearchTaskVariablesWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTaskVariablesResponse, error) {
	rsp, err := c.SearchTaskVariablesWithBody(ctx, taskId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTaskVariablesResponse(rsp)
}

func (c *ClientWithResponses) SearchTaskVariablesWithResponse(ctx context.Context, taskId string, body SearchTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTaskVariablesResponse, error) {
	rsp, err := c.SearchTaskVariables(ctx, taskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTaskVariablesResponse(rsp)
}

// GetVariableByIdWithResponse request returning *GetVariableByIdResponse
func (c *ClientWithResponses) GetVariableByIdWithResponse(ctx context.Context, variableId string, reqEditors ...RequestEditorFn) (*GetVariableByIdResponse, error) {
	rsp, err := c.GetVariableById(ctx, variableId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableByIdResponse(rsp)
}

// ParseGetFormResponse parses an HTTP response from a GetFormWithResponse call
func ParseGetFormResponse(rsp *http.Response) (*GetFormResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFormResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseSearchTasksResponse parses an HTTP response from a SearchTasksWithResponse call
func ParseSearchTasksResponse(rsp *http.Response) (*SearchTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TaskSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseGetTaskByIdResponse parses an HTTP response from a GetTaskByIdWithResponse call
func ParseGetTaskByIdResponse(rsp *http.Response) (*GetTaskByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaskByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseAssignTaskResponse parses an HTTP response from a AssignTaskWithResponse call
func ParseAssignTaskResponse(rsp *http.Response) (*AssignTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseCompleteTaskResponse parses an HTTP response from a CompleteTaskWithResponse call
func ParseCompleteTaskResponse(rsp *http.Response) (*CompleteTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseUnassignTaskResponse parses an HTTP response from a UnassignTaskWithResponse call
func ParseUnassignTaskResponse(rsp *http.Response) (*UnassignTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseSaveDraftTaskVariablesResponse parses an HTTP response from a SaveDraftTaskVariablesWithResponse call
func ParseSaveDraftTaskVariablesResponse(rsp *http.Response) (*SaveDraftTaskVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveDraftTaskVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchTaskVariablesResponse parses an HTTP response from a SearchTaskVariablesWithResponse call
func ParseSearchTaskVariablesResponse(rsp *http.Response) (*SearchTaskVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTaskVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VariableSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseGetVariableByIdResponse parses an HTTP response from a GetVariableByIdWithResponse call
func ParseGetVariableByIdResponse(rsp *http.Response) (*GetVariableByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VariableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}
