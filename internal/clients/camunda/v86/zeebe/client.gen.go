// Package zeebe provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package zeebe

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for PartitionHealth.
const (
	Dead      PartitionHealth = "dead"
	Healthy   PartitionHealth = "healthy"
	Unhealthy PartitionHealth = "unhealthy"
)

// Defines values for PartitionRole.
const (
	Follower PartitionRole = "follower"
	Inactive PartitionRole = "inactive"
	Leader   PartitionRole = "leader"
)

// BrokerInfo Provides information on a broker node.
type BrokerInfo struct {
	// Host The hostname for reaching the broker.
	Host *string `json:"host,omitempty"`

	// NodeId The unique (within a cluster) node ID for the broker.
	NodeId *int32 `json:"nodeId,omitempty"`

	// Partitions A list of partitions managed or replicated on this broker.
	Partitions *[]Partition `json:"partitions,omitempty"`

	// Port The port for reaching the broker.
	Port *int32 `json:"port,omitempty"`

	// Version The broker version.
	Version *string `json:"version,omitempty"`
}

// Changeset JSON object with changed task attribute values.
//
// The following attributes can be adjusted with this endpoint, additional attributes
// will be ignored:
//
// * `candidateGroups` - reset by providing an empty list
// * `candidateUsers` - reset by providing an empty list
// * `dueDate` - reset by providing an empty String
// * `followUpDate` - reset by providing an empty String
//
// Providing any of those attributes with a `null` value or omitting it preserves
// the persisted attribute's value.
//
// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
// This ensures correct event emission for assignee changes.
type Changeset struct {
	// CandidateGroups The list of candidate groups of the task. Reset by providing an empty list.
	CandidateGroups *[]string `json:"candidateGroups"`

	// CandidateUsers The list of candidate users of the task. Reset by providing an empty list.
	CandidateUsers *[]string `json:"candidateUsers"`

	// DueDate The due date of the task. Reset by providing an empty String.
	DueDate *time.Time `json:"dueDate"`

	// FollowUpDate The follow-up date of the task. Reset by providing an empty String.
	FollowUpDate         *time.Time             `json:"followUpDate"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Partition Provides information on a partition within a broker node.
type Partition struct {
	// Health Describes the current health of the partition.
	Health *PartitionHealth `json:"health,omitempty"`

	// PartitionId The unique ID of this partition.
	PartitionId *int32 `json:"partitionId,omitempty"`

	// Role Describes the Raft role of the broker for a given partition.
	Role *PartitionRole `json:"role,omitempty"`
}

// PartitionHealth Describes the current health of the partition.
type PartitionHealth string

// PartitionRole Describes the Raft role of the broker for a given partition.
type PartitionRole string

// ProblemDetail A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type ProblemDetail struct {
	// Detail An explanation of the problem in more detail.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI identifying the origin of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code for this problem.
	Status *int32 `json:"status,omitempty"`

	// Title A summary of the problem type.
	Title *string `json:"title,omitempty"`

	// Type A URI identifying the problem type.
	Type *string `json:"type,omitempty"`
}

// TopologyResponse The response of a topology request.
type TopologyResponse struct {
	// Brokers A list of brokers that are part of this cluster.
	Brokers *[]BrokerInfo `json:"brokers"`

	// ClusterSize The number of brokers in the cluster.
	ClusterSize *int32 `json:"clusterSize"`

	// GatewayVersion The version of the Zeebe Gateway.
	GatewayVersion *string `json:"gatewayVersion"`

	// PartitionsCount The number of partitions are spread across the cluster.
	PartitionsCount *int32 `json:"partitionsCount"`

	// ReplicationFactor The configured replication factor for this cluster.
	ReplicationFactor *int32 `json:"replicationFactor"`
}

// UserTaskAssignmentRequest defines model for UserTaskAssignmentRequest.
type UserTaskAssignmentRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "assign".
	Action *string `json:"action"`

	// AllowOverride By default, the task is reassigned if it was already assigned. Set this to `false` to return an error in such cases. The task must then first be unassigned to be assigned again. Use this when you have users picking from group task queues to prevent race conditions.
	AllowOverride *bool `json:"allowOverride"`

	// Assignee The assignee for the user task. The assignee must not be empty or `null`.
	Assignee *string `json:"assignee,omitempty"`
}

// UserTaskCompletionRequest defines model for UserTaskCompletionRequest.
type UserTaskCompletionRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "complete".
	Action *string `json:"action"`

	// Variables The variables to complete the user task with.
	Variables *map[string]interface{} `json:"variables"`
}

// UserTaskUpdateRequest defines model for UserTaskUpdateRequest.
type UserTaskUpdateRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "update".
	Action *string `json:"action"`

	// Changeset JSON object with changed task attribute values.
	//
	// The following attributes can be adjusted with this endpoint, additional attributes
	// will be ignored:
	//
	// * `candidateGroups` - reset by providing an empty list
	// * `candidateUsers` - reset by providing an empty list
	// * `dueDate` - reset by providing an empty String
	// * `followUpDate` - reset by providing an empty String
	//
	// Providing any of those attributes with a `null` value or omitting it preserves
	// the persisted attribute's value.
	//
	// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
	// This ensures correct event emission for assignee changes.
	Changeset *Changeset `json:"changeset"`
}

// PatchUserTasksUserTaskKeyJSONRequestBody defines body for PatchUserTasksUserTaskKey for application/json ContentType.
type PatchUserTasksUserTaskKeyJSONRequestBody = UserTaskUpdateRequest

// PostUserTasksUserTaskKeyAssignmentJSONRequestBody defines body for PostUserTasksUserTaskKeyAssignment for application/json ContentType.
type PostUserTasksUserTaskKeyAssignmentJSONRequestBody = UserTaskAssignmentRequest

// PostUserTasksUserTaskKeyCompletionJSONRequestBody defines body for PostUserTasksUserTaskKeyCompletion for application/json ContentType.
type PostUserTasksUserTaskKeyCompletionJSONRequestBody = UserTaskCompletionRequest

// Getter for additional properties for Changeset. Returns the specified
// element and whether it was found
func (a Changeset) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Changeset
func (a *Changeset) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Changeset to handle AdditionalProperties
func (a *Changeset) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["candidateGroups"]; found {
		err = json.Unmarshal(raw, &a.CandidateGroups)
		if err != nil {
			return fmt.Errorf("error reading 'candidateGroups': %w", err)
		}
		delete(object, "candidateGroups")
	}

	if raw, found := object["candidateUsers"]; found {
		err = json.Unmarshal(raw, &a.CandidateUsers)
		if err != nil {
			return fmt.Errorf("error reading 'candidateUsers': %w", err)
		}
		delete(object, "candidateUsers")
	}

	if raw, found := object["dueDate"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'dueDate': %w", err)
		}
		delete(object, "dueDate")
	}

	if raw, found := object["followUpDate"]; found {
		err = json.Unmarshal(raw, &a.FollowUpDate)
		if err != nil {
			return fmt.Errorf("error reading 'followUpDate': %w", err)
		}
		delete(object, "followUpDate")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Changeset to handle AdditionalProperties
func (a Changeset) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CandidateGroups != nil {
		object["candidateGroups"], err = json.Marshal(a.CandidateGroups)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'candidateGroups': %w", err)
		}
	}

	if a.CandidateUsers != nil {
		object["candidateUsers"], err = json.Marshal(a.CandidateUsers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'candidateUsers': %w", err)
		}
	}

	if a.DueDate != nil {
		object["dueDate"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dueDate': %w", err)
		}
	}

	if a.FollowUpDate != nil {
		object["followUpDate"], err = json.Marshal(a.FollowUpDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'followUpDate': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetTopology request
	GetTopology(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserTasksUserTaskKeyWithBody request with any body
	PatchUserTasksUserTaskKeyWithBody(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUserTasksUserTaskKey(ctx context.Context, userTaskKey int64, body PatchUserTasksUserTaskKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserTasksUserTaskKeyAssignee request
	DeleteUserTasksUserTaskKeyAssignee(ctx context.Context, userTaskKey int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserTasksUserTaskKeyAssignmentWithBody request with any body
	PostUserTasksUserTaskKeyAssignmentWithBody(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUserTasksUserTaskKeyAssignment(ctx context.Context, userTaskKey int64, body PostUserTasksUserTaskKeyAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserTasksUserTaskKeyCompletionWithBody request with any body
	PostUserTasksUserTaskKeyCompletionWithBody(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUserTasksUserTaskKeyCompletion(ctx context.Context, userTaskKey int64, body PostUserTasksUserTaskKeyCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetTopology(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopologyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserTasksUserTaskKeyWithBody(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserTasksUserTaskKeyRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserTasksUserTaskKey(ctx context.Context, userTaskKey int64, body PatchUserTasksUserTaskKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserTasksUserTaskKeyRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserTasksUserTaskKeyAssignee(ctx context.Context, userTaskKey int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserTasksUserTaskKeyAssigneeRequest(c.Server, userTaskKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserTasksUserTaskKeyAssignmentWithBody(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserTasksUserTaskKeyAssignmentRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserTasksUserTaskKeyAssignment(ctx context.Context, userTaskKey int64, body PostUserTasksUserTaskKeyAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserTasksUserTaskKeyAssignmentRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserTasksUserTaskKeyCompletionWithBody(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserTasksUserTaskKeyCompletionRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserTasksUserTaskKeyCompletion(ctx context.Context, userTaskKey int64, body PostUserTasksUserTaskKeyCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserTasksUserTaskKeyCompletionRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetTopologyRequest generates requests for GetTopology
func NewGetTopologyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/topology")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserTasksUserTaskKeyRequest calls the generic PatchUserTasksUserTaskKey builder with application/json body
func NewPatchUserTasksUserTaskKeyRequest(server string, userTaskKey int64, body PatchUserTasksUserTaskKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserTasksUserTaskKeyRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewPatchUserTasksUserTaskKeyRequestWithBody generates requests for PatchUserTasksUserTaskKey with any type of body
func NewPatchUserTasksUserTaskKeyRequestWithBody(server string, userTaskKey int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserTasksUserTaskKeyAssigneeRequest generates requests for DeleteUserTasksUserTaskKeyAssignee
func NewDeleteUserTasksUserTaskKeyAssigneeRequest(server string, userTaskKey int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/assignee", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUserTasksUserTaskKeyAssignmentRequest calls the generic PostUserTasksUserTaskKeyAssignment builder with application/json body
func NewPostUserTasksUserTaskKeyAssignmentRequest(server string, userTaskKey int64, body PostUserTasksUserTaskKeyAssignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUserTasksUserTaskKeyAssignmentRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewPostUserTasksUserTaskKeyAssignmentRequestWithBody generates requests for PostUserTasksUserTaskKeyAssignment with any type of body
func NewPostUserTasksUserTaskKeyAssignmentRequestWithBody(server string, userTaskKey int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/assignment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUserTasksUserTaskKeyCompletionRequest calls the generic PostUserTasksUserTaskKeyCompletion builder with application/json body
func NewPostUserTasksUserTaskKeyCompletionRequest(server string, userTaskKey int64, body PostUserTasksUserTaskKeyCompletionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUserTasksUserTaskKeyCompletionRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewPostUserTasksUserTaskKeyCompletionRequestWithBody generates requests for PostUserTasksUserTaskKeyCompletion with any type of body
func NewPostUserTasksUserTaskKeyCompletionRequestWithBody(server string, userTaskKey int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/completion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetTopologyWithResponse request
	GetTopologyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTopologyResponse, error)

	// PatchUserTasksUserTaskKeyWithBodyWithResponse request with any body
	PatchUserTasksUserTaskKeyWithBodyWithResponse(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserTasksUserTaskKeyResponse, error)

	PatchUserTasksUserTaskKeyWithResponse(ctx context.Context, userTaskKey int64, body PatchUserTasksUserTaskKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserTasksUserTaskKeyResponse, error)

	// DeleteUserTasksUserTaskKeyAssigneeWithResponse request
	DeleteUserTasksUserTaskKeyAssigneeWithResponse(ctx context.Context, userTaskKey int64, reqEditors ...RequestEditorFn) (*DeleteUserTasksUserTaskKeyAssigneeResponse, error)

	// PostUserTasksUserTaskKeyAssignmentWithBodyWithResponse request with any body
	PostUserTasksUserTaskKeyAssignmentWithBodyWithResponse(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserTasksUserTaskKeyAssignmentResponse, error)

	PostUserTasksUserTaskKeyAssignmentWithResponse(ctx context.Context, userTaskKey int64, body PostUserTasksUserTaskKeyAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserTasksUserTaskKeyAssignmentResponse, error)

	// PostUserTasksUserTaskKeyCompletionWithBodyWithResponse request with any body
	PostUserTasksUserTaskKeyCompletionWithBodyWithResponse(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserTasksUserTaskKeyCompletionResponse, error)

	PostUserTasksUserTaskKeyCompletionWithResponse(ctx context.Context, userTaskKey int64, body PostUserTasksUserTaskKeyCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserTasksUserTaskKeyCompletionResponse, error)
}

type GetTopologyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TopologyResponse
}

// Status returns HTTPResponse.Status
func (r GetTopologyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopologyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserTasksUserTaskKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r PatchUserTasksUserTaskKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserTasksUserTaskKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserTasksUserTaskKeyAssigneeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r DeleteUserTasksUserTaskKeyAssigneeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserTasksUserTaskKeyAssigneeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserTasksUserTaskKeyAssignmentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r PostUserTasksUserTaskKeyAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserTasksUserTaskKeyAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserTasksUserTaskKeyCompletionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r PostUserTasksUserTaskKeyCompletionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserTasksUserTaskKeyCompletionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetTopologyWithResponse request returning *GetTopologyResponse
func (c *ClientWithResponses) GetTopologyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTopologyResponse, error) {
	rsp, err := c.GetTopology(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopologyResponse(rsp)
}

// PatchUserTasksUserTaskKeyWithBodyWithResponse request with arbitrary body returning *PatchUserTasksUserTaskKeyResponse
func (c *ClientWithResponses) PatchUserTasksUserTaskKeyWithBodyWithResponse(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserTasksUserTaskKeyResponse, error) {
	rsp, err := c.PatchUserTasksUserTaskKeyWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserTasksUserTaskKeyResponse(rsp)
}

func (c *ClientWithResponses) PatchUserTasksUserTaskKeyWithResponse(ctx context.Context, userTaskKey int64, body PatchUserTasksUserTaskKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserTasksUserTaskKeyResponse, error) {
	rsp, err := c.PatchUserTasksUserTaskKey(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserTasksUserTaskKeyResponse(rsp)
}

// DeleteUserTasksUserTaskKeyAssigneeWithResponse request returning *DeleteUserTasksUserTaskKeyAssigneeResponse
func (c *ClientWithResponses) DeleteUserTasksUserTaskKeyAssigneeWithResponse(ctx context.Context, userTaskKey int64, reqEditors ...RequestEditorFn) (*DeleteUserTasksUserTaskKeyAssigneeResponse, error) {
	rsp, err := c.DeleteUserTasksUserTaskKeyAssignee(ctx, userTaskKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserTasksUserTaskKeyAssigneeResponse(rsp)
}

// PostUserTasksUserTaskKeyAssignmentWithBodyWithResponse request with arbitrary body returning *PostUserTasksUserTaskKeyAssignmentResponse
func (c *ClientWithResponses) PostUserTasksUserTaskKeyAssignmentWithBodyWithResponse(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserTasksUserTaskKeyAssignmentResponse, error) {
	rsp, err := c.PostUserTasksUserTaskKeyAssignmentWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserTasksUserTaskKeyAssignmentResponse(rsp)
}

func (c *ClientWithResponses) PostUserTasksUserTaskKeyAssignmentWithResponse(ctx context.Context, userTaskKey int64, body PostUserTasksUserTaskKeyAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserTasksUserTaskKeyAssignmentResponse, error) {
	rsp, err := c.PostUserTasksUserTaskKeyAssignment(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserTasksUserTaskKeyAssignmentResponse(rsp)
}

// PostUserTasksUserTaskKeyCompletionWithBodyWithResponse request with arbitrary body returning *PostUserTasksUserTaskKeyCompletionResponse
func (c *ClientWithResponses) PostUserTasksUserTaskKeyCompletionWithBodyWithResponse(ctx context.Context, userTaskKey int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserTasksUserTaskKeyCompletionResponse, error) {
	rsp, err := c.PostUserTasksUserTaskKeyCompletionWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserTasksUserTaskKeyCompletionResponse(rsp)
}

func (c *ClientWithResponses) PostUserTasksUserTaskKeyCompletionWithResponse(ctx context.Context, userTaskKey int64, body PostUserTasksUserTaskKeyCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserTasksUserTaskKeyCompletionResponse, error) {
	rsp, err := c.PostUserTasksUserTaskKeyCompletion(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserTasksUserTaskKeyCompletionResponse(rsp)
}

// ParseGetTopologyResponse parses an HTTP response from a GetTopologyWithResponse call
func ParseGetTopologyResponse(rsp *http.Response) (*GetTopologyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopologyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopologyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchUserTasksUserTaskKeyResponse parses an HTTP response from a PatchUserTasksUserTaskKeyWithResponse call
func ParsePatchUserTasksUserTaskKeyResponse(rsp *http.Response) (*PatchUserTasksUserTaskKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserTasksUserTaskKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	}

	return response, nil
}

// ParseDeleteUserTasksUserTaskKeyAssigneeResponse parses an HTTP response from a DeleteUserTasksUserTaskKeyAssigneeWithResponse call
func ParseDeleteUserTasksUserTaskKeyAssigneeResponse(rsp *http.Response) (*DeleteUserTasksUserTaskKeyAssigneeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserTasksUserTaskKeyAssigneeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	}

	return response, nil
}

// ParsePostUserTasksUserTaskKeyAssignmentResponse parses an HTTP response from a PostUserTasksUserTaskKeyAssignmentWithResponse call
func ParsePostUserTasksUserTaskKeyAssignmentResponse(rsp *http.Response) (*PostUserTasksUserTaskKeyAssignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserTasksUserTaskKeyAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	}

	return response, nil
}

// ParsePostUserTasksUserTaskKeyCompletionResponse parses an HTTP response from a PostUserTasksUserTaskKeyCompletionWithResponse call
func ParsePostUserTasksUserTaskKeyCompletionResponse(rsp *http.Response) (*PostUserTasksUserTaskKeyCompletionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserTasksUserTaskKeyCompletionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	}

	return response, nil
}
